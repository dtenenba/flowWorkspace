\name{add}
\alias{add}
\alias{add,GatingHierarchy,filter-method}
\alias{add,GatingHierarchy,quadGate-method}
\alias{add,GatingSet,filter-method}
\alias{add,GatingSet,filterList-method}
\alias{add,GatingSet,list-method}
\alias{add,GatingSetList,filter-method}
\alias{add,GatingSetList,filterList-method}
\alias{add,GatingSetList,list-method}
\alias{recompute}
\alias{recompute,GatingSet-method}
\alias{recompute,GatingSetList-method}
\alias{Rm}
\alias{Rm,character,GatingHierarchy,character-method}
\alias{Rm,character,GatingSet,character-method}
\alias{Rm,character,GatingSetList,character-method}
\alias{setGate}
\alias{setGate,GatingHierarchy,character,filter-method}
\alias{setGate,GatingHierarchy,numeric,filter-method}
\alias{setGate,GatingSet,ANY,filterList-method}
\alias{setGate,GatingSet,ANY,list-method}
\title{Create a GatingSet and add/remove the flowCore gate(or population) to/from a GatingHierarchy/GatingSet.}
\arguments{
  \item{wf}{A \code{GatingHierrarchy} or \code{GatingSet}}

  \item{envir}{A \code{GatingHierrarchy} or
  \code{GatingSet}}

  \item{x}{A \code{GatingSet}}

  \item{y}{a node index within a \code{GatingSet}. It is
  the root node if unspecified}

  \item{action}{A \code{filter} or a list of \code{filter}s
  to be added to the \code{GatingHierarchy} or
  \code{GatingSet}.}

  \item{names}{a \code{character} vector of length
  four,which specifies the population names resulted by
  adding a \code{quadGate}. The order of the names is
  clock-wise starting from the top left quadrant
  population.}

  \item{...}{some other arguments to specify how the gates
  are added to the gating tree. \itemize{ \item parent: a
  \code{character} scalar to specify the parent node name
  where the new gate to be added to, by default it is
  NULL,which indicates the root node \item name: a
  \code{character} scalar to specify the node name of
  population that is generated by the gate to be added.
  The default value is NULL,then the name will be extracted
  from the filterId of the gate to be added \item negated:
  a \code{logical} scalar to specify whether the gate is
  negated,which means the the population outside of the
  gate will be kept as the result population.  It is FALSE
  by default.  }}

  \item{symbol}{A \code{character} identifies the
  population node in a \code{GatingHierrarchy} or
  \code{GatingSet} to remove}

  \item{subSymbol}{Not used.}
}
\value{
  \code{GatingSet} method returns a \code{GatingSet} object
  with just root node.  \code{add} method returns a
  population node ID (or four population node IDs when
  adding a \code{quadGate}) that uniquely identify the
  population node within a \code{GatingHierarchy}.
}
\description{
  \code{GatingSet} method creates a gatingset from a
  flowSet with the ungated data as the root node.
  \code{add} method add the flowCore gate to a
  GatingHierarchy/GatingSet. \code{setGate} method update
  the gate of one population node in
  GatingHierarchy/GatingSet. \code{Rm} method Remove the
  population node from a GatingHierarchy/GatingSet. They
  are equivalent to the \code{workFlow},\code{add} and
  \code{Rm} methods in \code{flowCore} package.
  \code{recompute} method does the actual gating after the
  gate is added,i.e. calculating the event indices
  according to the gate definition.
}
\examples{
\dontrun{
    data(GvHD)
#select raw flow data
    fs<-GvHD[1:3]

#transform the raw data
    tf <- transformList(colnames(fs[[1]])[3:6], asinh, transformationId="asinh")
    fs_trans<-transform(fs,tf)

#add transformed data to a gatingset
    gs <- GatingSet(fs_trans)
    gs
    getNodes(gs[[1]]) #only contains root node

#add one gate
    rg <- rectangleGate("FSC-H"=c(200,400), "SSC-H"=c(250, 400),
        filterId="rectangle")

    nodeID<-add(gs, rg)#it is added to root node by default if parent is not specified
    nodeID
    getNodes(gs[[1]]) #the second population is named after filterId of the gate

#add a quadGate
    qg <- quadGate("FL1-H"=2, "FL2-H"=4)
    nodeIDs<-add(gs,qg,parent="rectangle")
    nodeIDs #quadGate produces four population nodes
    getNodes(gs[[1]]) #population names are named after dimensions of gate if not specified

#add a boolean Gate
    bg<-booleanFilter(`CD15 FITC-CD45 PE+`|`CD15 FITC+CD45 PE-`)
    bg
    nodeID2<-add(gs,bg,parent="rectangle")
    nodeID2
    getNodes(gs[[1]])
#do the actual gating
    recompute(gs)

#plot one gate for one sample
    plotGate(gs[[1]],"rectangle")
    plotGate(gs[[1]],nodeIDs) #may be smoothed automatically if there are not enough events after gating

#plot gates across samples using lattice plot
    plotGate(gs,nodeID)
#plot all gates for one sample
    plotGate(gs[[1]])#boolean gate is skipped by default
    plotGate(gs[[1]],bool=TRUE)

#plot the gating hierarchy
    require(Rgraphviz)
    plot(gs[[1]])
#remove one node causing the removal of all the descendants
    Rm('rectangle', gs)
    getNodes(gs[[1]])
 }
}
\seealso{
  \code{\link{GatingSet-class}}
}

